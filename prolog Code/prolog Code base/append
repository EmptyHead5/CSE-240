my_append([], L, L).
my_append([H|T], L, [H|RL]) :- my_append(T, L, RL).


这是一个十分简单但是也是游泳的例子，来帮助理解prolog的递归和回溯。
首先我们需要明切，调用这个代码的形式的前提是：
my_append([1, 2, 3], [4, 5, 6], Result)
如果我们用旧的语言习惯去查看代码很容易造成错误。
在my_append([H|T], L, [H|RL]) 中需要明切[H｜T]确实是将数组的元素分开为X和T，但是当函数回溯的过程中这也被代表加入H在RL的头部。

在我们的例子中，代码会逐步将1，2，3分解为[]，用来满足第一个条件，此时将会吧[4,5,6]赋值给L。
这时候prolog的内部回溯方式就开始有了作用，会逐步的将每一次递归所舍弃的H逐步添加到L的头部。
