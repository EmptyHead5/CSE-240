my_append([], L, L).
my_append([H|T], L, [H|RL]) :- my_append(T, L, RL).


这是一个十分简单但是也是游泳的例子，来帮助理解prolog的递归和回溯。
首先我们需要明切，调用这个代码的形式的前提是：
my_append([1, 2, 3], [4, 5, 6], Result)
如果我们用旧的语言习惯去查看代码很容易造成错误。
在my_append([H|T], L, [H|RL]) 中需要明切[H｜T]确实是将数组的元素分开为X和T，但是当函数回溯的过程中这也被代表加入H在RL的头部。

在我们的例子中，代码会逐步将1，2，3分解为[]，用来满足第一个条件，此时将会吧[4,5,6]赋值给L。
这时候prolog的内部回溯方式就开始有了作用，会逐步的将每一次递归所舍弃的H逐步添加到L的头部。

当代码注意到第一个传入数组被分解为空是，则满足了基本规则的要求，就开始回溯的过程，
基本规则在某些需求下十分重要！！


回溯其实可以很简单的理解，每一次我们调用my_append的时候，它都会递归并且重新调用自己，这也导致了上一个未完成的函数在等待多个调用自身的过程完成。
回溯则是递归到尽头或者说某个规定的停止点的时候，则需要将递归的结果一层层的返回给上一层未完成的函数，来保证函数完成
